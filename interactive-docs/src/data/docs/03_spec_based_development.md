# 3부. 스펙 기반 개발의 핵심

## 학습 목표
이 장을 마치면 다음을 이해하게 됩니다:
- 좋은 스펙의 정의와 3가지 필수 조건
- 스펙 작성의 7단계 방법론
- 실전 스펙 작성 예제 (3가지 난이도)
- 스펙 작성 시 주의사항

---

## 3.1 좋은 스펙이란 무엇인가

### 개념
스펙(Specification)은 **"무엇을 만들 것인가"를 명확하게 정의한 문서**입니다. 바이브코딩에서 스펙은 AI가 코드를 생성할 때 참고하는 가장 중요한 자료입니다.

### 좋은 스펙의 3가지 필수 조건

#### 1. 명확성: 모호함 없는 요구사항

**문제: 모호한 스펙**
```
"사용자가 로그인할 수 있어야 한다"
```

이 문장에는 다양한 해석이 가능합니다:
- 이메일 로그인인가, 소셜 로그인인가?
- 로그인 성공 후 어디로 리다이렉트?
- 로그인 실패 시 에러 메시지는?
- 세션은 얼마나 유지되어야 하나?

**개선: 명확한 스펙**
```
"사용자는 이메일과 비밀번호로 로그인한다.
- 이메일 형식 검증: RFC 5322 표준
- 비밀번호 길이: 최소 8자
- 로그인 성공 시: 홈 페이지로 리다이렉트, JWT 토큰 발급
- 로그인 실패 시: '이메일 또는 비밀번호가 틀렸습니다' 메시지 표시
- 세션 유지: 30일 (또는 30일 미로그인 시 자동 로그아웃)
- 로그인 시도 3회 실패 시 15분간 로그인 차단"
```

**명확성 체크리스트**
- [ ] "할 수 있다"는 표현 제거, 구체적인 액션으로 변경
- [ ] 모든 조건을 "만약 A라면 B를 한다" 형식으로 표현
- [ ] 숫자 단위 명시 (초, 분, 바이트 등)
- [ ] 예외 상황과 에러 경우 모두 포함

#### 2. 완결성: 필요한 모든 정보 포함

**불완전한 스펙**
```
"상품 검색 기능을 만든다"
```

빠진 정보:
- 검색 대상: 상품명, 설명, 카테고리 중 어디?
- 검색 방식: 정확 검색, 부분 검색, 퍼지 검색?
- 결과 정렬: 어떤 기준으로?
- 결과 개수: 무제한, 페이징?

**완전한 스펙**
```
"상품 검색 기능:
1. 검색 범위
   - 상품명: 부분 검색 (대소문자 구분 없음)
   - 카테고리: 정확 검색
   - 가격: 범위 검색 (최소값 <= 상품가격 <= 최대값)

2. 정렬 옵션
   - 최신순: 생성 시간 역순
   - 인기순: 조회수 + 판매량의 가중합
   - 가격 낮음/높음순: 상품가격 순서

3. 페이징
   - 한 페이지당 20개 상품 표시
   - 총 상품 개수 반환

4. 성능
   - 응답 시간 < 500ms
   - 동시 사용자 1,000명 처리 가능"
```

**완결성 체크리스트**
- [ ] 모든 기능의 입력값(input) 정의됨
- [ ] 모든 기능의 출력값(output) 정의됨
- [ ] 가능한 모든 경로(happy path, error path) 포함
- [ ] 성능/용량 요구사항 명시
- [ ] 보안 요구사항 명시
- [ ] 외부 시스템과의 연동 명시

#### 3. 실행 가능성: AI가 바로 구현할 수 있는 수준

**실행 불가능한 스펙**
```
"획기적인 AI 기반 추천 알고리즘을 구현한다"
```

이 스펙은 너무 추상적이어서 AI가 어디서 시작해야 할지 모릅니다.

**실행 가능한 스펙**
```
"추천 알고리즘:
1. 데이터 수집
   - 사용자의 최근 30일 구매 이력
   - 같은 카테고리 상품들의 평점

2. 추천 로직
   - 사용자가 구매한 상품의 카테고리 식별
   - 같은 카테고리에서 평점 4.0 이상의 상품 선택
   - 사용자가 이미 구매한 상품 제외
   - 상위 5개 추천

3. 캐싱
   - 추천 결과 24시간 캐싱
   - 새로운 구매 시 캐시 초기화"
```

**실행 가능성 체크리스트**
- [ ] 사용할 기술 스택 명시 (언어, 프레임워크, DB)
- [ ] 알고리즘이 구체적으로 설명됨 (의사코드 수준)
- [ ] 필요한 라이브러리/도구 명시
- [ ] 기존 코드나 외부 자산 참고 가능하도록 제시
- [ ] 한 번의 AI 요청으로 1-2시간 내에 완성 가능한 범위

---

## 3.2 스펙 작성의 7단계 방법론

### 7단계 개요

좋은 스펙을 작성하기 위한 체계적인 프로세스입니다. 각 단계를 순서대로 진행합니다.

### Step 1: 기능 목적과 사용자 시나리오 정의

**목표**: "이 기능을 왜 만드는가"와 "누가 어떻게 사용하는가"를 명확히 합니다.

**작성 방법**

1. **기능 목적 작성**
   - 한두 문장으로 기능의 핵심 목적 정의
   - "~를 가능하게 한다" 형식 피하기

   ❌ 나쁜 예: "사용자가 상품을 검색할 수 있게 한다"
   ✅ 좋은 예: "사용자는 자신이 원하는 상품을 빠르게 찾아 구매 결정 시간을 단축할 수 있다"

2. **주요 사용자 정의**
   - 누가 이 기능을 사용하는가?
   - 고객? 관리자? 운영팀?

3. **사용자 시나리오 작성**
   - 사용자가 어떤 상황에서 어떻게 기능을 사용하는가?
   - 최소 3가지 시나리오 작성

   **예시: 상품 검색 기능**
   ```
   시나리오 1: 일반적인 검색
   - 사용자 민수는 "생일선물 500만원대 남성용 시계"를 검색한다
   - 가격대 필터를 사용해 원하는 상품을 찾는다
   - 비슷한 상품들을 비교해서 구매한다

   시나리오 2: 급한 구매
   - 사용자 영희는 "내일까지 배송 가능한 운동화"를 검색한다
   - 배송 조건 필터를 사용한다
   - 가장 먼저 나온 상품을 구매한다

   시나리오 3: 알럴림 설정
   - 사용자 철수는 특정 상품이 할인될 때 알림받고 싶다
   - 찜 목록의 상품에 가격 알림을 설정한다
   ```

**산출물**
```
기능명: 상품 검색

목적:
사용자가 자신의 필요에 맞는 상품을 빠르고 효율적으로 찾을 수 있게 하여
구매 결정 시간을 단축하고 만족도를 높인다.

주요 사용자:
- 일반 고객 (구매자)

사용자 시나리오:
[위의 예시 참고]
```

### Step 2: 데이터 구조 및 스키마 설계

**목표**: 필요한 모든 데이터를 정의합니다.

**작성 방법**

1. **필요한 데이터 항목 나열**
   - 기능을 구현하기 위해 필요한 모든 데이터
   - 사용자 입력 데이터
   - 시스템에서 저장해야 하는 데이터

2. **각 데이터 항목 상세 정의**
   - 데이터 타입
   - 크기/범위
   - 필수/선택 여부
   - 유효성 검증 규칙

3. **데이터 관계 정의**
   - 어떤 데이터가 어떤 데이터와 연결되는가?

**예시: 상품 검색 데이터 모델**
```
Product (상품)
├─ id: UUID (필수, PK)
├─ name: String (필수, 최대 100자)
├─ category: String (필수, 사전 정의된 카테고리만 가능)
├─ price: Integer (필수, 0 이상)
├─ description: String (선택, 최대 5000자)
├─ rating: Float (선택, 0.0 ~ 5.0)
├─ reviewCount: Integer (선택, 0 이상)
├─ createdAt: Timestamp (필수)
└─ updatedAt: Timestamp (필수)

SearchQuery (검색 쿼리)
├─ keyword: String (선택, 최대 100자)
├─ categoryFilter: String (선택)
├─ minPrice: Integer (선택, 0 이상)
├─ maxPrice: Integer (선택, minPrice 이상)
├─ sortBy: Enum (선택, 'newest'/'popular'/'priceAsc'/'priceDesc')
├─ pageNumber: Integer (필수, 1 이상)
└─ pageSize: Integer (필수, 기본값 20)
```

### Step 3: API 엔드포인트 및 인터페이스 명세

**목표**: 외부와의 상호작용 방식을 정의합니다.

**작성 방법**

1. **엔드포인트 정의**
   - HTTP 메서드 (GET, POST, PUT, DELETE)
   - 경로 (Path)
   - 요청 파라미터
   - 응답 형식

2. **각 응답 코드 정의**
   - 성공 (200, 201 등)
   - 클라이언트 오류 (400, 401, 404 등)
   - 서버 오류 (500 등)

**예시: 상품 검색 API**
```
엔드포인트: GET /api/products/search

요청:
Query Parameters:
- keyword (String, 선택): 검색 키워드
- category (String, 선택): 카테고리
- minPrice (Integer, 선택): 최소 가격
- maxPrice (Integer, 선택): 최대 가격
- sortBy (String, 선택): 정렬 기준
  가능한 값: 'newest', 'popular', 'priceAsc', 'priceDesc'
  기본값: 'newest'
- page (Integer, 필수): 페이지 번호, 최소 1
- pageSize (Integer, 선택): 한 페이지 크기, 기본값 20, 최대 100

응답 성공 (200):
{
  "success": true,
  "data": {
    "products": [
      {
        "id": "uuid",
        "name": "상품명",
        "category": "카테고리",
        "price": 50000,
        "rating": 4.5,
        "reviewCount": 120
      }
    ],
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 150,
      "totalPages": 8
    }
  }
}

응답 실패 (400):
{
  "success": false,
  "error": {
    "code": "INVALID_PRICE_RANGE",
    "message": "minPrice는 maxPrice보다 작아야 합니다"
  }
}
```

### Step 4: 비즈니스 로직 플로우차트

**목표**: 기능의 동작 흐름을 시각적으로 표현합니다.

**작성 방법**

1. **주요 흐름 정의**
   - Happy path (모든 것이 정상 작동하는 경우)
   - Alternative paths (특수한 경우들)

2. **각 단계에서의 결정점 명시**
   - 조건문: "만약 X라면 Y를 한다"

3. **문자 기반 플로우 작성**
   - 다이어그램이 아닌 텍스트로 표현 (코드로 변환하기 쉽도록)

**예시: 상품 검색 로직**
```
사용자 입력 검증
│
├─ 필수 파라미터 확인 (page, pageSize)
├─ 가격 범위 검증 (minPrice <= maxPrice)
├─ 정렬 값 검증 (사전 정의된 값만 허용)
│
↓
데이터베이스 쿼리 생성
│
├─ SELECT 절: 필요한 필드만 선택
├─ WHERE 절: 검색 조건 적용
│  ├─ keyword: LIKE '%keyword%' (대소문자 무시)
│  ├─ category: = category (정확 검색)
│  └─ price: BETWEEN minPrice AND maxPrice
├─ ORDER BY: sortBy에 따라 정렬
│  ├─ 'newest': createdAt DESC
│  ├─ 'popular': (rating + reviewCount) DESC
│  └─ 'priceAsc'/'priceDesc': price ASC/DESC
└─ LIMIT/OFFSET: 페이징 적용

결과 반환
│
├─ 찾은 상품 개수 > 0: 상품 목록 + 페이지 정보 반환
└─ 찾은 상품 개수 = 0: 빈 결과 배열 + 페이지 정보 반환
```

### Step 5: 에러 핸들링 및 예외 상황 정의

**목표**: 모든 가능한 문제 상황을 대비합니다.

**작성 방법**

1. **가능한 모든 에러 시나리오 나열**
2. **각 에러에 대한 처리 방법 정의**
3. **사용자에게 표시할 메시지 작성**

**예시: 상품 검색 에러 정의**
```
입력값 에러:
1. 가격 범위 오류
   - 조건: minPrice > maxPrice
   - 처리: 400 Bad Request 반환
   - 사용자 메시지: "최소 가격이 최대 가격보다 클 수 없습니다"

2. 잘못된 정렬 값
   - 조건: sortBy가 허용된 값이 아님
   - 처리: 기본값('newest')으로 대체
   - 사용자 메시지: 없음 (자동 처리)

3. 페이지 번호 오류
   - 조건: page < 1 또는 page > totalPages
   - 처리: 해당 페이지가 없으면 빈 결과 반환
   - 사용자 메시지: "요청한 페이지가 없습니다"

데이터베이스 에러:
1. 데이터베이스 연결 실패
   - 처리: 재시도 3회 (각 1초 간격)
   - 최종 실패 시: 500 Internal Server Error
   - 사용자 메시지: "일시적으로 서비스를 이용할 수 없습니다. 잠시 후 다시 시도해주세요"

2. 쿼리 타임아웃
   - 조건: 쿼리 실행 시간 > 5초
   - 처리: 쿼리 중단, 500 에러 반환
   - 사용자 메시지: 위와 동일

성능 에러:
1. 응답 시간 초과 (> 500ms)
   - 모니터링: 로그에 경고 기록
   - 처리: 정상 범위로 복구될 때까지 모니터링
```

### Step 6: 성능 요구사항 및 제약조건

**목표**: 기술적 제약을 명확히 합니다.

**작성 방법**

1. **성능 요구사항**
   - 응답 시간
   - 동시 사용자 처리량
   - 데이터 크기 제한

2. **시스템 제약**
   - 메모리 사용량
   - 저장소 크기
   - 네트워크 대역폭

3. **보안 제약**
   - 인증 요구 여부
   - 암호화 필요성
   - 접근 제어 규칙

**예시: 상품 검색 성능 요구사항**
```
응답 시간:
- 일반적인 검색: < 200ms
- 복잡한 필터링: < 500ms
- P99 응답 시간: < 1000ms

처리량:
- 동시 사용자: 10,000명
- 초당 요청: 100,000 req/s
- 피크 타임 트래픽: 5배

데이터:
- 상품 개수: 최대 1,000,000개
- 응답 페이로드 크기: < 1MB
- 검색 결과: 최대 100개 상품

보안:
- 인증: 필요 없음 (공개 API)
- 사용 제한: IP당 분당 1000 요청
- 데이터: 암호화 전송 (HTTPS 필수)
```

### Step 7: 테스트 시나리오 및 검증 기준

**목표**: 기능이 제대로 작동하는지 확인하는 방법을 정의합니다.

**작성 방법**

1. **단위 테스트 케이스**
2. **통합 테스트 케이스**
3. **성능 테스트 기준**

**예시: 상품 검색 테스트 시나리오**
```
단위 테스트:
1. 쿼리 생성 로직
   - 정상: keyword 필터링 적용됨
   - 정상: 가격 범위 필터링 적용됨
   - 정상: 정렬 기준 적용됨
   - 에러: minPrice > maxPrice일 때 검증 실패

2. 페이징 로직
   - 정상: page=1, pageSize=20일 때 처음 20개 반환
   - 정상: page=2, pageSize=20일 때 21-40번째 반환
   - 정상: totalPages 계산이 올바름

통합 테스트:
1. 검색 성공 케이스
   - GET /api/products/search?keyword=시계
   - 응답: 200, 관련 상품 목록

2. 검색 실패 케이스
   - GET /api/products/search?minPrice=100000&maxPrice=50000
   - 응답: 400, 에러 메시지

3. 빈 결과 케이스
   - GET /api/products/search?category=nonexistent
   - 응답: 200, 빈 배열

성능 테스트:
1. 응답 시간 검증
   - 조건: 1,000,000개 상품 데이터베이스
   - 측정: 1000번 요청의 평균 응답 시간
   - 기준: < 200ms

2. 동시성 테스트
   - 조건: 10,000명 동시 접속
   - 측정: 응답 시간, 에러율
   - 기준: 에러율 < 0.1%
```

---

## 3.3 실전 스펙 작성 예제

### 예제 1: 간단한 기능 - 사용자 인증 스펙

**난이도**: ⭐ (초급)
**예상 구현 시간**: 2-4시간

```markdown
## 기능명: 사용자 로그인

### 1단계: 기능 목적과 사용자 시나리오

목적:
사용자가 이메일과 비밀번호로 안전하게 로그인하여
개인 계정에 접근할 수 있다.

주요 사용자:
- 모든 등록된 고객

사용자 시나리오:
- 시나리오 1: 정상 로그인
  사용자가 올바른 이메일과 비밀번호를 입력하면
  성공 메시지와 함께 홈 화면으로 이동한다.

- 시나리오 2: 잘못된 비밀번호
  사용자가 올바른 이메일이지만 잘못된 비밀번호를 입력하면
  "이메일 또는 비밀번호가 틀렸습니다" 메시지를 본다.

- 시나리오 3: 존재하지 않는 계정
  사용자가 등록되지 않은 이메일로 로그인 시도하면
  "이메일 또는 비밀번호가 틀렸습니다" 메시지를 본다.

### 2단계: 데이터 구조

User (사용자)
├─ id: UUID (PK)
├─ email: String (필수, 고유값, 이메일 형식)
├─ passwordHash: String (필수, bcrypt 해시)
├─ createdAt: Timestamp
├─ lastLoginAt: Timestamp (선택)
└─ loginAttempts: Integer (기본값 0)

SessionToken (세션)
├─ token: String (PK, JWT)
├─ userId: UUID (FK → User.id)
├─ expiresAt: Timestamp
└─ createdAt: Timestamp

### 3단계: API 엔드포인트

POST /api/auth/login
요청:
{
  "email": "user@example.com",
  "password": "password123"
}

응답 성공 (200):
{
  "success": true,
  "data": {
    "token": "jwt_token",
    "expiresAt": "2024-12-31T23:59:59Z",
    "user": {
      "id": "uuid",
      "email": "user@example.com"
    }
  }
}

응답 실패 (401):
{
  "success": false,
  "error": {
    "code": "INVALID_CREDENTIALS",
    "message": "이메일 또는 비밀번호가 틀렸습니다"
  }
}

### 4단계: 로직 플로우

입력 검증
│
├─ email 필드 존재 확인
├─ password 필드 존재 확인
├─ email 형식 검증 (RFC 5322)
└─ password 길이 확인 (최소 1자)
│
↓
사용자 조회
│
├─ 이메일로 사용자 검색
├─ 사용자 미존재 → 401 에러 반환
└─ 사용자 존재 → 다음 단계로
│
↓
비밀번호 검증
│
├─ bcrypt로 입력 비밀번호 검증
├─ 비밀번호 불일치 → 401 에러 + loginAttempts 증가
└─ 비밀번호 일치 → 다음 단계로
│
↓
로그인 제한 확인
│
├─ loginAttempts >= 3이고 마지막 시도 < 15분 → 429 Throttled
└─ 그 외 → 다음 단계로
│
↓
토큰 발급
│
├─ JWT 토큰 생성 (만료: 30일)
├─ 세션 데이터베이스 저장
├─ lastLoginAt 업데이트
├─ loginAttempts 초기화
└─ 토큰 반환

### 5단계: 에러 처리

입력값 에러:
- email 누락: "이메일을 입력해주세요" (400)
- password 누락: "비밀번호를 입력해주세요" (400)
- email 형식 오류: "올바른 이메일 형식이 아닙니다" (400)

인증 에러:
- 사용자 미존재: "이메일 또는 비밀번호가 틀렸습니다" (401)
- 비밀번호 오류: "이메일 또는 비밀번호가 틀렸습니다" (401)
- 로그인 시도 초과: "너무 많이 시도했습니다. 15분 후에 다시 시도해주세요" (429)

시스템 에러:
- 데이터베이스 오류: "일시적인 오류가 발생했습니다" (500)
- 토큰 발급 오류: "로그인 처리 중 오류가 발생했습니다" (500)

### 6단계: 성능 요구사항

응답 시간:
- 로그인 요청: < 500ms

보안:
- 모든 비밀번호는 bcrypt로 해싱 (cost factor: 12)
- 세션 토큰은 JWT (알고리즘: HS256)
- HTTPS 필수

### 7단계: 테스트 시나리오

단위 테스트:
- ✓ 정상 로그인 성공
- ✓ 잘못된 비밀번호 처리
- ✓ 등록되지 않은 이메일 처리
- ✓ 로그인 시도 제한
- ✓ 토큰 생성 검증

통합 테스트:
- ✓ 로그인 → 홈 페이지 접근 → 성공
- ✓ 로그인 후 토큰 만료 → 재로그인 필요
```

---

## 3.4 스펙 작성 시 주의사항

### 1. 기술 스택 명시의 중요성

**문제: 불명확한 기술**
```
"데이터베이스를 사용하여 사용자 정보를 저장한다"
```

이것만으로는 어떤 DB를 사용할지 모릅니다.

**해결: 구체적인 기술 명시**
```
"데이터베이스: PostgreSQL 14.0
ORM: Sequelize (Node.js)
스키마: 첨부된 schema.sql 참고
마이그레이션: Sequelize migrations 사용"
```

**필수 명시 기술**
- 프로그래밍 언어: "Node.js 18.0"
- 프레임워크: "Express.js 4.18"
- 데이터베이스: "PostgreSQL 14"
- 인증 방식: "JWT (HS256)"
- 캐싱: "Redis 7.0"
- 라이브러리 버전: "lodash 4.17"

### 2. 폴더 구조 및 네이밍 컨벤션

**스펙에 포함할 정보**
```
폴더 구조:
src/
├─ controllers/
│  └─ authController.js      // 라우팅 처리
├─ services/
│  └─ authService.js         // 비즈니스 로직
├─ models/
│  └─ User.js                // 데이터 모델
├─ middlewares/
│  ├─ authMiddleware.js      // 인증 미들웨어
│  └─ errorHandler.js        // 에러 처리
└─ routes/
   └─ authRoutes.js          // 라우트 정의

네이밍 컨벤션:
- 함수: camelCase (loginUser, createSession)
- 클래스: PascalCase (User, AuthService)
- 상수: UPPER_SNAKE_CASE (JWT_SECRET, MAX_LOGIN_ATTEMPTS)
- DB 컬럼: snake_case (created_at, password_hash)
```

### 3. 의존성 및 라이브러리 버전 지정

**중요한 이유**
- 라이브러리 버전에 따라 동작이 달라질 수 있음
- 버전 미명시 시 최신 버전이 설치되어 호환성 문제 발생 가능

**명시 방법**
```
필수 라이브러리:
- bcryptjs: ^2.4.3 (비밀번호 해싱)
- jsonwebtoken: ^9.0.0 (JWT 생성)
- sequelize: ^6.31.0 (ORM)
- express: ^4.18.2 (웹 프레임워크)
- dotenv: ^16.0.3 (환경 변수)

선택 라이브러리:
- morgan: ^1.10.0 (HTTP 로깅, 디버깅용)
- helmet: ^7.0.0 (보안 헤더)

명시하지 않아도 되는 라이브러리:
- Node.js 표준 라이브러리 (fs, path, crypto 등)
```

---

## 3.5 좋은 스펙 vs 나쁜 스펙: 비교 분석

### 나쁜 스펙의 특징

```
"상품 관리 기능을 만든다.
상품을 추가, 수정, 삭제할 수 있어야 하고,
검색도 가능해야 한다.
성능은 빨라야 하고,
보안도 좋아야 한다."
```

문제점:
- ❌ 모호한 표현: "빨라야 한다", "좋아야 한다"
- ❌ 구체적 기준 없음: 어느 정도가 "빠른" 것인가?
- ❌ 데이터 정의 부재: 상품의 필드는?
- ❌ 에러 처리 미정의: 실패 시?
- ❌ 기술 스택 불명: 어떤 언어, DB?

### 좋은 스펙의 특징

```
기능명: 상품 관리 API (관리자용)

1. 상품 추가
   POST /api/admin/products
   요청: {name, price, description, category, stock}
   응답: 201, 생성된 상품 정보
   검증: 가격 > 0, 재고 >= 0
   권한: 관리자만 가능

2. 상품 수정
   PUT /api/admin/products/:id
   요청: {name?, price?, description?, category?, stock?}
   응답: 200, 수정된 상품 정보
   조건: 존재하는 상품만 수정 가능

3. 상품 삭제
   DELETE /api/admin/products/:id
   응답: 204 (No Content)
   조건: 재고가 0일 때만 삭제 가능

4. 상품 검색
   GET /api/products/search?keyword=&category=&page=
   응답: 200, {products[], pagination{}}
   응답시간: < 200ms
   성능: 1,000,000개 상품 기준

5. 에러 처리
   - 권한 없음: 403
   - 상품 미존재: 404
   - 데이터 유효성: 400
   - 서버 오류: 500

기술 스택:
- Node.js 18 + Express 4
- PostgreSQL 14
- Sequelize ORM
```

장점:
- ✅ 구체적인 수치: "< 200ms"
- ✅ 상세한 데이터: 필드명, 타입, 제약
- ✅ 명확한 에러: 각 경우의 응답 코드
- ✅ 기술 명시: 스택이 명확함
- ✅ 실행 가능: AI가 바로 코드 작성 가능

---

## 3.6 스펙 작성 템플릿

### 최소 스펙 템플릿

```markdown
## 기능명: [기능 이름]

### 1. 목적 및 시나리오
[기능을 왜 만드는가, 누가 어떻게 사용하는가]

### 2. API 엔드포인트
[HTTP 메서드] /api/[경로]
요청: [데이터 구조]
응답: [성공 데이터], [에러 처리]

### 3. 비즈니스 로직
[단계별 처리 흐름]

### 4. 데이터 모델
[필요한 데이터 구조]

### 5. 에러 처리
[가능한 에러와 처리 방법]

### 6. 성능 요구사항
[응답 시간, 동시성, 저장소 등]

### 7. 테스트 케이스
[주요 테스트 시나리오]

### 8. 기술 스택
[언어, 프레임워크, DB, 라이브러리]
```

---

## 3.7 스펙 검증 체크리스트

스펙을 작성한 후 다음을 확인하세요:

**명확성**
- [ ] 모든 "할 수 있다"를 구체적인 액션으로 변경했는가?
- [ ] 숫자 단위를 명시했는가? (초, 분, 바이트 등)
- [ ] 모든 용어가 명확하게 정의되었는가?

**완결성**
- [ ] 모든 입력값이 정의되었는가?
- [ ] 모든 출력값이 정의되었는가?
- [ ] 모든 에러 케이스를 다루었는가?
- [ ] 성능 요구사항이 명시되어 있는가?
- [ ] 보안 고려사항이 포함되어 있는가?

**실행 가능성**
- [ ] 기술 스택이 명시되어 있는가?
- [ ] 외부 의존성이 명시되어 있는가?
- [ ] 한 번의 요청으로 2시간 내 완성 가능한가?
- [ ] AI가 따라할 수 있는 수준의 구체성인가?

---

## 3.8 다음 장 미리보기

다음 장에서는 Claude와 효과적으로 협업하는 방법을 배웁니다:
- 프롬프트 엔지니어링 기초
- 코드 생성 요청 패턴
- 코드 리뷰 및 개선 요청
- 디버깅 및 문제 해결

---

## 학습 체크리스트

이 장을 완료한 후 다음 항목들을 확인하세요:

- [ ] 좋은 스펙의 3가지 필수 조건을 설명할 수 있다
- [ ] 스펙 작성의 7단계 방법론을 이해하고 적용할 수 있다
- [ ] 실제 기능에 대해 스펙을 작성할 수 있다
- [ ] 스펙 검증 체크리스트를 활용할 수 있다
- [ ] 나쁜 스펙과 좋은 스펙의 차이를 알고 있다
- [ ] 기술 스택과 요구사항을 명확히 명시할 수 있다
