# 4부. Claude와 효과적으로 협업하기

## 학습 목표
이 장을 마치면 다음을 이해하게 됩니다:
- 명확한 지시문 작성법과 컨텍스트 제공 방법
- 코드 생성 요청 시 효과적인 패턴
- AI 생성 코드에 대한 리뷰 및 개선 요청 방법
- 에러 상황에서의 효과적인 디버깅 전략

---

## 4.1 프롬프트 엔지니어링 기초

### 명확한 지시문 작성법

#### 원칙 1: 구체적인 목표 먼저

❌ 나쁜 예:
```
"로그인 기능을 만들어줘"
```

✅ 좋은 예:
```
"사용자가 이메일과 비밀번호로 로그인하는 REST API 엔드포인트를
Node.js/Express로 구현해줘. 성공 시 JWT 토큰을 반환하고,
실패 시 401 상태 코드와 에러 메시지를 반환해야 한다."
```

#### 원칙 2: 제약조건 명시

❌ 나쁜 예:
```
"데이터베이스 관련 코드 작성"
```

✅ 좋은 예:
```
"PostgreSQL 14, Sequelize ORM을 사용하여
User 테이블을 정의하는 모델 코드를 작성해줘.
필드: id (UUID, PK), email (String, unique),
passwordHash (String), createdAt (Timestamp)"
```

#### 원칙 3: 맥락 제공

❌ 나쁜 예:
```
"에러 처리 코드 추가해줘"
```

✅ 좋은 예:
```
"현재 코드는 데이터베이스 연결 실패를 처리하지 않고 있다.
다음을 수행하는 에러 처리를 추가해줘:
- 연결 실패 시 자동으로 3회까지 재시도
- 모든 재시도 실패 시 로그 기록 후 HTTP 500 응답"
```

### 컨텍스트 제공 방법

#### 방법 1: 이전 코드 제시

```
"이 코드를 보고 성능 개선해줘:

[함수 코드]

문제점: 대량의 데이터(100만 개)를 처리할 때 시간이 오래 걸린다.
개선 목표: 응답 시간을 50% 이하로 단축"
```

#### 방법 2: 파일 구조 제시

```
"우리 프로젝트는 다음 구조를 사용한다:

src/
├─ controllers/
├─ services/
├─ models/
└─ middlewares/

이 구조에 맞게 [기능]을 구현해줘"
```

#### 방법 3: 유사 코드 예시

```
"여기 기존에 구현된 코드가 있다:
[기존 코드 - userId로 사용자 조회]

위와 유사한 방식으로 productId로 상품을 조회하는
함수를 만들어줘"
```

### 단계별 요청 vs 한 번에 요청

#### 전략 1: 한 번에 요청 (단순 기능)

```
"회원가입 API를 만들어줘:
- 엔드포인트: POST /api/auth/signup
- 입력: email, password
- 검증: 이메일 형식, 비밀번호 8자 이상
- 출력: 201 상태, JWT 토큰
- DB: PostgreSQL, Sequelize"
```

**장점**: 빠르고 효율적
**단점**: 복잡한 기능에선 원하는 결과가 안 나올 수 있음

#### 전략 2: 단계별 요청 (복잡한 기능)

```
1단계: "상품 검색 기능의 데이터베이스 스키마를 설계해줘"
    → 결과 확인

2단계: "[1단계 결과] 기반으로 검색 로직을 구현해줘"
    → 결과 확인

3단계: "[1단계, 2단계 결과] 기반으로 REST API를 만들어줘"
    → 최종 결과
```

**장점**: 각 단계마다 확인 가능, 수정이 쉬움
**단점**: 시간이 더 걸림

---

## 4.2 코드 생성 요청 패턴

### 패턴 1: 구현 vs 설명

#### "~를 구현해줘" (❌ 덜 효과적)
```
"에러 핸들링 미들웨어를 구현해줘"

→ Claude가 일반적인 미들웨어를 생성
→ 프로젝트의 특성이 반영되지 않을 수 있음
```

#### "~를 위한 코드를 작성해줘" (✅ 더 효과적)
```
"다음 요구사항을 만족하는 에러 핸들링 미들웨어 코드를 작성해줘:
- 모든 비동기 함수의 에러를 캐치
- 에러 타입에 따라 적절한 HTTP 상태 코드 반환
- 에러 메시지는 사용자에게 공개해도 되는 메시지만 전달
- 내부 에러 정보는 로그에만 기록"
```

### 패턴 2: 예시 코드 제공

#### 예시 없음 (❌)
```
"인증 미들웨어를 만들어줘"
```

#### 예시 있음 (✅)
```
"인증 미들웨어를 만들어줘.
다음은 기존 미들웨어의 예시야:

[기존 로깅 미들웨어 코드]

위 스타일을 유지하면서 JWT 토큰을 검증하는
미들웨어를 만들어줘"
```

**효과**: Claude가 프로젝트 스타일을 일관되게 유지

### 패턴 3: 제약조건 명시

#### 명시 없음 (❌)
```
"사용자 정보를 캐싱하는 로직을 추가해줘"
```

#### 명시 있음 (✅)
```
"사용자 정보를 캐싱하는 로직을 추가해줘.
제약조건:
- Redis 7.0 사용
- 캐시 키: user:{userId}
- TTL: 1시간
- 사용자 정보 업데이트 시 캐시 무효화
- 캐시 실패는 데이터베이스에서 직접 조회"
```

### 패턴 4: 좋은 코드 생성 요청 템플릿

```
작업: [짧은 설명]

목표:
[이 코드가 달성해야 하는 목표]

입력:
[함수/메서드의 입력값]

출력:
[함수/메서드의 출력값]

제약조건:
- [기술 스택]
- [성능 요구사항]
- [보안 요구사항]

참고:
[기존 코드, 프로젝트 구조, 유사 함수 등]
```

**예시**:
```
작업: 페이지네이션 함수 작성

목표:
대량의 배열 데이터를 페이지별로 분할하는 범용 함수

입력:
- data: 배열
- pageNumber: 페이지 번호 (1부터 시작)
- pageSize: 한 페이지 크기

출력:
{
  data: [페이지 데이터],
  pagination: {page, pageSize, total, totalPages}
}

제약조건:
- TypeScript 사용
- 입력값 검증 포함
- 성능: O(n) 이하

참고:
기존 코드에서 사용 중인 유틸리티 함수들
```

---

## 4.3 코드 리뷰 및 개선 요청

### 코드 검증 체크리스트

Claude가 생성한 모든 코드는 다음 항목을 확인합니다:

#### 기능 정확성
```
□ 스펙의 모든 요구사항을 만족하는가?
□ 가능한 모든 입력값을 처리하는가?
□ 엣지 케이스(빈 배열, null 값 등)를 처리하는가?
□ 예상된 출력 형식이 정확한가?
```

#### 보안성
```
□ SQL injection 취약점이 없는가?
□ XSS 취약점이 없는가?
□ CSRF 보호가 적용되어 있는가?
□ 민감한 정보(비밀번호, API 키)가 로그에 나타나지 않는가?
□ 인증/인가 검증이 적절한가?
□ 입력값 검증이 충분한가?
```

#### 에러 처리
```
□ 모든 가능한 에러 상황을 처리하는가?
□ 에러 메시지가 사용자 친화적인가?
□ 에러 로깅이 충분한가?
□ 재시도 로직이 필요한가?
```

#### 성능
```
□ N+1 쿼리 문제가 없는가?
□ 불필요한 데이터베이스 접근이 없는가?
□ 루프 내에서 비효율적인 작업이 없는가?
□ 캐싱 기회가 있는가?
□ 응답 시간이 요구사항을 만족하는가?
```

#### 코드 품질
```
□ 변수명이 명확한가?
□ 함수가 단일 책임을 가지는가?
□ 중복 코드가 없는가?
□ 주석이 필요한가?
□ 기존 코드 스타일과 일치하는가?
```

### 리팩토링 요청 방법

#### 방법 1: 구체적인 문제 지적

❌ 나쁜 리뷰:
```
"이 함수 좀 정리해줘"
```

✅ 좋은 리뷰:
```
"이 함수에서:
1. 데이터베이스 조회가 반복되고 있다.
   시작할 때 한 번만 조회하도록 수정해줘.
2. 변수명이 명확하지 않다.
   'temp', 'result' 대신 'activeUsers', 'userGroup' 등으로 변경해줘.
3. 중복된 검증 로직이 있다.
   별도의 함수로 추출해줘."
```

#### 방법 2: 원하는 결과 명시

```
"현재 이 함수의 응답 시간은 2초인데,
500ms 이하로 개선해줘.
힌트: 데이터베이스 인덱스 활용, 캐싱, 배치 조회 등"
```

#### 방법 3: 비교를 통한 개선

```
"여기 두 구현이 있다:

[구현 A]
[구현 B]

둘을 비교해서 더 나은 방식을 설명해주고,
우리 프로젝트에 맞게 최적화해줘."
```

### 성능 최적화 요청

#### 단계 1: 현재 성능 측정

```
"이 함수를 100,000개 데이터로 테스트했을 때:
- 실행 시간: 5초
- 메모리 사용: 500MB
- 데이터베이스 쿼리: 100회"
```

#### 단계 2: 목표 설정

```
"목표:
- 실행 시간: < 1초
- 메모리: < 100MB
- 데이터베이스 쿼리: < 5회"
```

#### 단계 3: 최적화 요청

```
"위의 성능 목표를 달성하도록
[함수명]을 최적화해줘.
현재 코드: [...]"
```

---

## 4.4 디버깅 및 문제 해결

### 에러 로그 공유 방법

#### 효과적인 에러 리포팅

❌ 나쁜 보고:
```
"에러가 발생했어. 뭐가 문제야?"
```

✅ 좋은 보고:
```
"다음 코드를 실행하면 에러가 발생해:

[코드]

에러 메시지:
TypeError: Cannot read property 'id' of undefined
at line 42 in userService.js

언제 발생: 사용자 로그인 시도할 때
재현 방법:
1. 등록되지 않은 이메일로 로그인 시도
2. 에러 발생
"
```

**포함할 정보**:
1. 실행한 코드
2. 전체 에러 메시지 (스택 트레이스)
3. 입력값 (입력할 때 사용한 값)
4. 예상 결과
5. 실제 결과
6. 재현 방법

### 문제 상황 재현 시나리오 작성

```
"다음 시나리오에서 문제가 발생한다:

초기 상태:
- 데이터베이스: 100명의 사용자
- Redis: 비어있음

실행 순서:
1. 사용자 A가 상품을 검색 (결과: 50개)
2. 사용자 B가 같은 검색 (결과: 50개)
3. 관리자가 새로운 상품 2개를 추가
4. 사용자 A가 다시 검색 (예상: 52개, 실제: 50개)

문제:
캐시가 새 데이터를 반영하지 못했다."
```

### 단계별 디버깅 접근법

#### 단계 1: 문제 범위 좁히기

```
"문제를 재현했다.
다음을 확인해줘:
1. 데이터베이스 쿼리는 정상인가?
2. 응답 데이터는 정상인가?
3. 프론트엔드에서 잘못 처리하고 있는 것은 아닌가?"
```

#### 단계 2: 원인 파악

```
"쿼리는 정상이고 응답도 정상이다.
로그를 분석해보니 다음을 발견했다:
[로그 내용]

원인이 뭔가?"
```

#### 단계 3: 해결책 구현

```
"원인이 [원인]이라고 파악했다.
이를 해결하는 방법은?
제약조건: 기존 데이터를 잃지 않아야 함"
```

### 일반적인 문제와 해결 전략

#### 문제 1: "작동하지 않아"

이렇게 구체화합니다:
```
"어떤 부분이 작동하지 않나?
- 함수를 호출할 수 없다?
- 호출되지만 에러가 난다?
- 호출되고 완료되지만 결과가 잘못되었다?

위 중 어느 것인가?"
```

#### 문제 2: "느려"

이렇게 구체화합니다:
```
"얼마나 느린가?
- 현재 시간: ?초
- 목표 시간: ?초
- 얼마나 많은 데이터 처리: ?"
```

#### 문제 3: "에러 메시지가 없다"

이렇게 해결합니다:
```
"에러를 추적하기 위해 다음을 추가해줘:
1. 각 함수 시작 시: console.log('함수명 시작')
2. 데이터베이스 쿼리 전: 쿼리 로그
3. 캐시 접근 시: 히트/미스 로그
4. 각 조건분기: console.log('조건 A 선택됨')"
```

---

## 4.5 프롬프트 템플릿 모음

### 템플릿 1: 새로운 기능 구현

```
[기능명] 구현 요청

현재 상황:
- 프로젝트: [프로젝트명]
- 기술 스택: [스택]
- 현재 구조: [간단한 구조 설명]

구현 요청:
[상세한 스펙]

예상 결과:
[결과 형식]

제약조건:
- [기술 제약]
- [성능 제약]
- [보안 제약]
```

### 템플릿 2: 기존 코드 개선

```
[코드명] 개선 요청

현재 상황:
[현재 코드]

문제점:
- [문제 1]
- [문제 2]
- [문제 3]

목표:
- [개선 목표 1]
- [개선 목표 2]

제약조건:
- [제약 1]
- [제약 2]
```

### 템플릿 3: 버그 수정

```
[버그 설명]

재현 방법:
1. [단계 1]
2. [단계 2]
3. [단계 3]

예상 결과:
[어떻게 작동해야 하는가]

실제 결과:
[현재 어떻게 작동하는가]

관련 코드:
[코드]

에러 로그:
[에러 메시지]
```

### 템플릿 4: 성능 최적화

```
[함수/모듈명] 성능 최적화

현재 성능:
- 실행 시간: [시간]
- 메모리: [용량]
- 데이터베이스 쿼리: [개수]

목표 성능:
- 실행 시간: [시간]
- 메모리: [용량]
- 데이터베이스 쿼리: [개수]

테스트 환경:
- 데이터 크기: [개수]
- 평가 방식: [방법]

현재 코드:
[코드]
```

---

## 4.6 효과적인 협업을 위한 체크리스트

### 요청 전 확인

- [ ] 요청이 구체적인가?
- [ ] 필요한 모든 정보를 제공했는가?
- [ ] 제약조건을 명시했는가?
- [ ] 기존 코드 예시를 제공했는가?
- [ ] 성공 기준이 명확한가?

### 응답 받은 후 확인

- [ ] 스펙을 정확히 구현했는가?
- [ ] 보안 취약점이 없는가?
- [ ] 성능이 요구사항을 만족하는가?
- [ ] 에러 처리가 적절한가?
- [ ] 기존 코드와 일관성이 있는가?

### 피드백 제공 시 확인

- [ ] 구체적인 문제점을 지적했는가?
- [ ] 개선 방향을 명시했는가?
- [ ] 현재 코드와 개선안을 함께 제시했는가?
- [ ] 우선순위를 정했는가?

---

## 4.7 다음 장 미리보기

다음 장에서는 Claude의 강력한 확장 기능인 MCP (Model Context Protocol)를 배웁니다:
- MCP의 개념과 이점
- 환경별 MCP 지원 현황
- MCP 설정 및 활용 방법
- 실전 MCP 활용 사례
- 커스텀 MCP 서버 개발

---

## 학습 체크리스트

이 장을 완료한 후 다음 항목들을 확인하세요:

- [ ] 명확한 지시문의 3가지 원칙을 이해한다
- [ ] 코드 생성 요청의 4가지 패턴을 알고 있다
- [ ] Claude 생성 코드의 검증 체크리스트를 활용할 수 있다
- [ ] 효과적인 코드 리뷰 의견을 작성할 수 있다
- [ ] 성능 최적화 요청을 구조적으로 할 수 있다
- [ ] 버그 보고를 상세하고 명확하게 할 수 있다
- [ ] 프롬프트 템플릿을 프로젝트에 맞게 커스터마이징할 수 있다
