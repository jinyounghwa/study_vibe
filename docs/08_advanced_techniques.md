# 8부. 고급 기법 및 베스트 프랙티스

## 학습 목표
이 장을 마치면 다음을 이해하게 됩니다:
- 복잡한 기능을 작은 단위로 분해하는 전략
- 성능 최적화 기법과 병목 지점 개선
- 보안 요구사항 명시 및 검증
- 테스트 자동화와 TDD 접근법
- 코드 품질 모니터링

---

## 8.1 복잡한 기능 분해하기

### 큰 기능을 작은 단위로 나누기

#### 전체 프로세스 다이어그램 작성

```
큰 기능: "실시간 알림 시스템"

분해 단계 1: 주요 책임별 분해
├─ 알림 생성
├─ 알림 저장
├─ 실시간 전송
└─ 알림 읽음 표시

분해 단계 2: 각 책임을 구현 가능한 단위로
├─ 알림 생성
│  ├─ 이벤트 감지
│  ├─ 알림 메시지 생성
│  └─ 사용자 필터링
├─ 알림 저장
│  ├─ 데이터베이스 저장
│  └─ 캐시 업데이트
└─ 실시간 전송
   ├─ WebSocket 연결
   ├─ 메시지 큐 (Redis/Kafka)
   └─ 클라이언트 전송

분해 단계 3: 구현 순서 결정
1단계: 알림 생성 로직 (독립적)
2단계: 데이터베이스 저장 (1단계 완료 후)
3단계: 캐시 최적화 (2단계 완료 후)
4단계: WebSocket 구현 (병렬 가능)
5단계: 메시지 큐 도입 (4단계 완료 후)
```

#### AI에 분해 작업 요청하기

```
개발자: "복잡한 기능 '실시간 알림 시스템'을 구현하려고 해.
다음을 해줄 수 있어?

1. 이 기능을 3-5개의 작은 하위 기능으로 분해
2. 각 하위 기능의 구현 난이도 평가
3. 의존성 관계 파악
4. 추천 구현 순서 제시
5. 각 단계별 예상 시간"

Claude: [분해 및 분석 제공]
```

### 의존성 관리 전략

#### 의존성 다이어그램

```
요청 수신
    ↓
요청 검증
    ↓
권한 확인 ←→ 인증
    ↓
데이터 로드
    ↓
비즈니스 로직
    ├─ 데이터 처리
    ├─ 외부 API 호출
    └─ 캐시 업데이트
    ↓
응답 생성
```

#### 의존성 최소화 원칙

```
원칙 1: 느슨한 결합 (Loose Coupling)

❌ 나쁜 예: UserService가 EmailService를 직접 호출
class UserService {
  create(userData) {
    const user = this.save(userData);
    this.emailService.sendWelcomeEmail(user); // 직접 호출
    return user;
  }
}

✅ 좋은 예: 이벤트를 통한 느슨한 결합
class UserService {
  create(userData) {
    const user = this.save(userData);
    this.eventBus.emit('user.created', user); // 이벤트 발행
    return user;
  }
}

class EmailService {
  constructor(eventBus) {
    this.eventBus.on('user.created', this.sendWelcomeEmail);
  }
}
```

### 점진적 구현 접근법

#### Step-by-Step 구현 계획

```
기능: "상품 검색 및 추천 시스템"

Step 1: 기본 검색 (1-2시간)
- 상품명으로 검색
- 결과 페이징
- 스펙: 정의됨

구현:
사용자: "검색 API를 구현해줘. 상품명 부분검색, 페이징 지원"
Claude: [코드 생성]

---

Step 2: 고급 필터링 (1-2시간)
- 카테고리 필터
- 가격대 필터
- 평점 필터

구현:
사용자: "Step 1의 검색 API에 다음 필터를 추가해줘:
- 카테고리 (정확 검색)
- 가격 범위 (minPrice, maxPrice)
- 평점 4.0 이상만"

---

Step 3: 정렬 기능 (30분)
- 최신순
- 인기순
- 가격순

구현:
사용자: "검색 결과의 정렬 옵션을 추가해줘.
정렬 방식: newest, popular, price_asc, price_desc"

---

Step 4: 캐싱 최적화 (1-2시간)
- Redis 캐싱
- 캐시 무효화 전략

구현:
사용자: "검색 결과를 Redis에 캐싱하도록 개선해줘.
- 캐시 키: search:{keyword}:{filters}:{sort}
- TTL: 1시간
- 상품 수정 시 해당 캐시 무효화"

---

Step 5: 개인화 추천 (2-3시간)
- 사용자 조회 이력 기반
- 협업 필터링

구현:
사용자: "사용자의 조회 이력을 기반으로 상품을 추천하는
기능을 추가해줘. 알고리즘: 유사 카테고리의 상품 추천"

각 Step이 독립적으로 동작 가능하며, Step이 완료될 때마다
실제 사용 가능한 기능이 추가됨
```

---

## 8.2 성능 최적화

### AI에게 성능 요구사항 전달하기

```
개발자: "이 검색 기능의 성능을 최적화해줘.

현재 상황:
- 1,000,000개 상품 데이터베이스
- 평균 응답 시간: 3초
- 동시 사용자: 100명
- 에러율: 0.5% (timeout)

성능 목표:
- 응답 시간: < 500ms (P99)
- 동시 사용자: 1,000명 (에러율 0%)
- 메모리: < 512MB

현재 코드:
[검색 함수 코드]

최적화 방향:
- 인덱싱
- 쿼리 최적화
- 캐싱
- 비동기 처리"

Claude: [성능 분석 및 최적화 코드 제공]
```

### 생성된 코드의 성능 분석

```
Step 1: 성능 측정

사용자: "최적화 전후로 성능을 측정해줄 수 있어?

테스트 조건:
- 데이터: 1,000,000개 상품
- 쿼리: 'laptop' 검색 (예상 결과: 50,000개)
- 동시성: 100명 동시 요청

측정 항목:
- 응답 시간
- 메모리 사용
- CPU 사용량
- 데이터베이스 쿼리 수"

Claude:
성능 비교 테이블:
│항목│최적화 전│최적화 후│개선율│
├───┼────────┼────────┼─────┤
│응답시간│3000ms│450ms│85%│
│메모리│800MB│300MB│62%│
│DB쿼리│50회│3회│94%│

개선 분석:
- 인덱스 추가로 쿼리 시간 90% 감소
- 캐싱으로 메모리 접근 속도 10배 향상
- 배치 조회로 데이터베이스 커넥션 80% 감소

---

Step 2: 병목 지점 개선 요청

사용자: "응답 시간이 아직 목표인 500ms에 못 미친다.
[응답 시간 프로필 데이터] 를 보니,
정렬 단계가 전체의 40%를 차지한다.
이를 개선해줄 수 있어?"

Claude: [정렬 최적화 코드]

결과: 응답 시간 → 350ms (목표 달성)
```

---

## 8.3 보안 고려사항

### 보안 요구사항 스펙에 포함하기

```markdown
## 보안 요구사항

### 인증 (Authentication)

사용자 식별:
- 모든 민감한 작업(개인 정보 조회, 결제 등)은 인증 필수
- 인증 방식: JWT (RS256)
- 토큰 유효시간: 1시간
- Refresh Token: 30일

비밀번호:
- 최소 8자, 대문자/소문자/숫자/특수문자 포함
- 해싱: bcrypt (cost factor 12)
- 이전 비밀번호 5개는 재사용 불가

---

### 인가 (Authorization)

역할 기반 접근 제어 (RBAC):
- 역할: admin, manager, user, guest
- 각 역할별 접근 가능 리소스 명시
- 리소스별 최소 필요 역할 명시

API 레벨 권한:
- 자신의 데이터만 조회 가능
- 다른 사용자 데이터 조회 시 403 Forbidden

---

### 데이터 보호

암호화:
- 전송: HTTPS (TLS 1.3)
- 저장: 민감한 정보는 AES-256으로 암호화
  - 신용카드번호
  - 주민번호
  - 비밀번호 (이미 해싱)

개인정보:
- 개인정보 접근 로그 기록
- 최소 필요한 정보만 수집
- 일정 기간 후 자동 삭제

---

### API 보안

입력 검증:
- 모든 입력값 검증 (타입, 길이, 형식)
- SQL injection 방지: 파라미터화 쿼리
- XSS 방지: HTML 이스케이핑

Rate Limiting:
- IP당: 분당 100 요청
- 사용자당: 분당 1000 요청
- 로그인 실패: 3회 이후 15분 차단

CSRF 방지:
- 상태 변경 요청(POST, PUT, DELETE)에 CSRF 토큰 필수
- SameSite=Strict 쿠키 설정

---

### 로깅 및 모니터링

보안 이벤트 로깅:
- 로그인 시도 (성공/실패)
- 권한 거부 (403)
- 데이터 접근 (민감 정보)
- 관리자 작업 (삭제, 수정)

로그 보관:
- 최소 90일 보관
- 위변조 방지 (append-only)
- 접근 제한 (관리자만)
```

### AI 생성 코드의 보안 취약점 검증

```
Step 1: 코드 검증 요청

개발자: "이 코드의 보안 취약점을 찾아줘.
[API 엔드포인트 코드]

특히 다음을 확인해줘:
- SQL injection 가능성
- XSS 취약점
- 인증/인가 누락
- 민감한 정보 노출"

Claude: [보안 분석]
발견된 취약점:
1. [심각] SQL injection 위험
   코드: `query("SELECT * FROM users WHERE id=" + userId)`
   해결: 파라미터화 쿼리 사용

2. [높음] 비밀번호가 평문으로 저장
   코드: `password: userData.password`
   해결: bcrypt로 해싱

3. [중간] Rate limiting 없음
   해결: express-rate-limit 미들웨어 추가

---

Step 2: 보안 개선 코드 생성

개발자: "위의 보안 취약점을 모두 해결한 코드를 만들어줘"

Claude: [개선된 코드]
```

### 인증/인가 구현 패턴

```typescript
// ✅ Good 패턴

// 1. 인증 미들웨어
async function authenticateRequest(req, res, next) {
  const token = req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'Missing token' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
}

// 2. 인가 미들웨어
function authorize(...allowedRoles) {
  return (req, res, next) => {
    if (!allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' });
    }
    next();
  };
}

// 3. 사용 예
app.delete(
  '/api/users/:id',
  authenticateRequest,
  authorize('admin'),
  deleteUser
);
```

---

## 8.4 테스트 자동화

### 테스트 코드 생성 요청

```
개발자: "다음 함수의 테스트 코드를 작성해줘.
[함수 코드]

테스트 범위:
1. 정상 케이스: 유효한 입력
2. 경계값: minPrice=0, maxPrice=최댓값
3. 에러 케이스: 잘못된 입력, 데이터베이스 연결 실패
4. 성능: 100,000개 데이터로 1초 이내 응답

테스트 프레임워크: Jest
테스트 커버리지 목표: 95%"

Claude: [테스트 코드 생성]
```

### TDD 접근법과 바이브코딩

```
Step 1: 테스트 작성

개발자: "사용자 인증 API를 테스트 주도로 개발하고 싶어.
다음 테스트를 먼저 작성해줄 수 있어?

테스트 케이스:
1. POST /api/auth/login에서 유효한 이메일과 비밀번호로 성공
2. 잘못된 비밀번호로 실패 (401)
3. 등록되지 않은 이메일로 실패 (401)
4. 이메일 필드 누락으로 실패 (400)"

Claude: [테스트 코드]

Step 2: 테스트 실행 (모두 실패)
$ npm test
FAIL: 4 tests failed (당연함, 구현이 없음)

Step 3: 최소 구현

개발자: "위의 테스트를 모두 통과하는
최소한의 구현을 만들어줄 수 있어?"

Claude: [최소 구현]

Step 4: 테스트 실행 (모두 통과)
$ npm test
PASS: 4 tests passed

Step 5: 리팩토링

개발자: "테스트는 통과하는데, 코드를 좀 더
깔끔하게 리팩토링해줄 수 있어?
- 에러 처리 개선
- 중복 제거
- 성능 최적화"

Claude: [리팩토링된 코드]

Step 6: 기능 추가

개발자: "다음 테스트를 추가해줄 수 있어?
- 로그인 3회 실패 후 15분 차단
- 토큰 만료 (1시간)
- 로그인 후 토큰 발급"

Claude: [새로운 테스트 + 구현]
```

### E2E 테스트 시나리오 작성

```
개발자: "전자상거래 플랫폼의 핵심 사용자 여정을 테스트하는
E2E 테스트를 작성해줄 수 있어?

시나리오: 고객이 상품을 검색해서 구매하고 주문 확인까지

단계:
1. 사용자 로그인
   → GET /api/auth/login으로 토큰 획득

2. 상품 검색
   → GET /api/products/search?keyword=laptop
   → 결과 확인 (최소 5개 이상)

3. 상품 상세 조회
   → GET /api/products/{productId}
   → 가격, 설명, 재고 확인

4. 장바구니 추가
   → POST /api/cart
   → 상품 ID, 수량 전송

5. 결제
   → POST /api/orders
   → 배송 주소, 결제 정보 전송
   → 주문 ID 반환

6. 주문 확인
   → GET /api/orders/{orderId}
   → 주문 상태 확인 ('completed')"

Claude: [E2E 테스트 코드]
```

---

## 8.5 성능 모니터링

### 성능 메트릭 정의

```
APM (Application Performance Monitoring) 메트릭:

응답 시간:
- P50 (중앙값): < 200ms
- P95 (95 percentile): < 500ms
- P99 (99 percentile): < 1000ms

처리량 (Throughput):
- 초당 요청: > 1000 req/s
- 동시 사용자: > 10,000

에러율:
- 5xx 에러: < 0.1%
- 4xx 에러: < 0.5%

리소스 사용:
- CPU: < 70%
- 메모리: < 80%
- 디스크: < 85%
```

### 모니터링 설정 요청

```
개발자: "애플리케이션의 성능을 모니터링할 수 있는
Prometheus + Grafana 대시보드를 구성해줄 수 있어?

메트릭:
- HTTP 요청 수 (엔드포인트별)
- 응답 시간 분포
- 에러 율 (HTTP 상태 코드별)
- 데이터베이스 쿼리 시간
- 메모리/CPU 사용량

알림:
- 응답 시간 > 1초 (P95)
- 에러율 > 1%
- 메모리 사용 > 90%"

Claude: [모니터링 설정 코드]
```

---

## 학습 체크리스트

이 장을 완료한 후 다음 항목들을 확인하세요:

- [ ] 복잡한 기능을 작은 단위로 분해할 수 있다
- [ ] 의존성 관계를 파악하고 관리할 수 있다
- [ ] 점진적 구현 접근법을 적용할 수 있다
- [ ] AI에게 성능 최적화를 효과적으로 요청할 수 있다
- [ ] 보안 요구사항을 명확히 명시할 수 있다
- [ ] AI 생성 코드의 보안 취약점을 검증할 수 있다
- [ ] 테스트 코드를 작성하도록 AI에게 요청할 수 있다
- [ ] TDD 접근법을 바이브코딩과 함께 적용할 수 있다
- [ ] E2E 테스트 시나리오를 작성할 수 있다
- [ ] 성능 메트릭을 정의하고 모니터링할 수 있다
